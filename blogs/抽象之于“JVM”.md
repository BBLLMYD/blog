
对于使用Java作为程序的开发者来说，Java虚拟机不会陌生，之所以把“JVM”给加了引号，是想说JVM发展到今天，
已经不再局限于“JVM（Java Virtual Machine）”。它本质上是对**输入字节码的处理平台，**
JVM的一系列规范也是针对字节码而言，Java语言可以通过编译器编译出符合JVM规范的字节码，
理论上其他语言也是完全可以这么做的，甚至你可以手写出一个满足JVM规范的字节码，
JVM也不会区别对待的，事实上确实也是这样，已经有越来越多的这种语言在涌现，eg：kotlin、Scala等等，
这些语言也可以称之为**JVM语言。**

<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/02/2-1.png?raw=true" width="400"></div>

所以JVM本身其实也理解成一个"规范"的概念，可以说是一个**负责解释编译满足规范的字节码**平台。

这里刚说的的编译其实也并不具体，一般说高级语言通过编译器的编译称为前端编译，虚拟机对字节码的编译称为后端编译。

既然是JVM是抽象的概念，实现起来也要规范的字节码，自然也就会有对JVM本身的规范，这样才有开源或闭源的不同的JVM实现。

现在网上关于JVM各种实现机制的资料非常多，但除了一些实战排查类主题的，
其他大多数理论内容其实都还是在周志明老师的《深入理解Java虚拟机》里，这当然是一本必读经典，
而关于**JVM规范**相关的内容却少被提起，
我认为理解上层规范定制的重要性对整体学习而言是其实也是很有必要的。。

虽然我们默认多是以HotSpot为讨论基准，但是还是应该要了解规范的内容。

<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/02/2-15-0.png?raw=true" width="500"></div>

  
> 计算机领域中的任何问题都可以通过加一个中间层来解决。
  
通过上面这个著名的理论，
其实我们JVM本质上也是个“中间件”，
它解决了C/C++这些需要程序编写者显式的管理内存的痛点。
并不是说显示管理内存就不好，
只是这样的方式对需要快速迭代和扩展的程序产生了很大阻力，
从业务的角度看多了很多“无用功”。

也正是JVM的存在，以及Java的动态分派等一些语言特性，降低了语言本身的使用门槛，
提高了灵活扩展的机制和空间，
得以让Java这种高级语言能够更普适
让语言本身更好的普及推广。这种好处最开始是需要以相对牺牲一些性能作为代价，
而JVM平台发展了到了今天，性能上已经不输于原来的C/C++了，
甚至一些场景下已经可以做到领先。

根据2/8定律，我们的一个进程内的程序的跑的最多的**热点代码往往只占大约20%，
而这部分热点代码可能占了80%的资源。**
JVM本身通过即时编译等手段对这种现象做了独立的优化，最大幅度的提升了性能。
而这些优化工作对程序开发者来说虽然是不需要可见的，但是如果了解JVM的优化逻辑，可能会有意识的写出更高效的代码。

    其实计算机中很多东西都可以视为为了解决某个问题而引入的一个“中间层”，
    而久而久之我们可能又会出于性能等一些因素考量，会去想办法消灭掉或者绕过一些“中间层”。
    JIT二次编译技术的目的其实就是为了消除JVM作为中间层带来的弊端，可见想要作为一个足够优秀的“中间层”，一定需有要其“过人之处”的。

从JVM初始加载字节码开始，整个类加载的过程，运行时区域布局，对象的实例化、定位、判断是否可回收，回收的算法等等，每一个步骤都可以拿出来单独展开大篇幅的讨论，
而且真的结合实际环境出现的形形色色问题来看，就真的是魔鬼藏在细节里，没有对JVM的架构足够了解和实际经验的累积，往往都会是很棘手的问题。

这篇文字尽量从抽象的视角，整体的来谈一谈关于JVM的部分内容，包括：

- [1. 类加载](https://github.com/BBLLMYD/blog/blob/master/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9CJVM%E2%80%9D.md#1%E5%85%B3%E4%BA%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD)
- [2. 内存布局](https://github.com/BBLLMYD/blog/blob/master/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9CJVM%E2%80%9D.md#2%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80)
- [3. 内存模型](https://github.com/BBLLMYD/blog/blob/master/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9CJVM%E2%80%9D.md#3%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm)
- [4. 运行期优化](https://github.com/BBLLMYD/blog/blob/master/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9CJVM%E2%80%9D.md#4%E5%85%B3%E4%BA%8E%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96)
- [5. 垃圾收集](https://github.com/BBLLMYD/blog/blob/master/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9CJVM%E2%80%9D.md#5%E5%85%B3%E4%BA%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86)
- [6. 处理工具](https://github.com/BBLLMYD/blog/blob/master/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9CJVM%E2%80%9D.md#5%E5%85%B3%E4%BA%8E%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7)
- [7. 其他 & 总结](https://github.com/BBLLMYD/blog/blob/master/blogs/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9CJVM%E2%80%9D.md#7%E5%85%B6%E4%BB%96--%E6%80%BB%E7%BB%93)

* * *

### 1.关于“类加载”

说到类加载我们会想到关于类加载的过程，类加载器的几种分类，双亲委派机制。关于这些机制和名词，我们会分别知道他们的作用。

如果在没有这些内容存在的情况下，有存在好的字节码文件需要去被加载使用，
其实就自然的引出了加载->验证—>准备->解析->初始化等这一系列必要的工作。
将这些工作以及字节码的来源等因素结合，也就对这个具体工作做一些列细化分类和不同时机的处理，
就构成了不同的“类加载器”对象。

而这种隔离分工同时带来了一些冲突安全隐患，由此也形成了解决这种安全问题的加载机制，这种协作模式名词就称之为“双亲委派模型”。

所以当我们在了解类加载器时，应该知道并不是因为先有了“双亲委派模型”所以类加载过程才安全，
而是**类加载过程中的安全需求催生出了这种模式也就是“双亲委派模型模型”。**

字节码的文件中存放一些二进制数据，而当我们用javap工具产看这些二进制文件的时候会发现内容被转译成了一些指令集如：iload、istore等，这些指令集实际上就是需要满足JVM规范的，而这个转译的工作就是我们最常接触的编译器来帮我们做好的，基于编译器领域也有很多优秀的开源工具组件如Lombok等等，可以帮我们提升开发效率，也提高代码的可读性，让Java程序本身看起来不再那么臃肿。

<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/02/2-5.png?raw=true" width="777"></div>
<div align=center>类加载的过程和机制</div>


### 2.关于“内存布局”

内存区域布局，为什么JVM规范中要明确将进程内存按照一定规则策略去划分，这样为什么可以更好的进行内存管理呢？
因为程序内创建**各种对象的数据类型以及存活周期粒度不同**，根据不同的档位分类来划分是高效的做法。

- 静态成员变量

- 动态成员变量

- 区域变量

- 短小紧凑的对象声明

- 庞大复杂的内存申请

根据的内存中对象的特点，要高效的使用内存，需要我们对程序中不同数据结构中不同对象做好分类管理的机制。

来保证Java在运行过程中对内存的申请、分配、管理的效率。这样对JVM本身来说既可以更合理管理以及最大化的利用内存空间**，对上层JVM使用者也可以抛区域出较明确的OOM信息，上层也可以更清晰的定位问题。
当我们在关于JVM相关的学习中迷茫在成百上千的JVM参数中，不妨**回到JVM规范**，可能有新的理解。

HotSpot由于其开源透明等特性，是十分优秀优秀的也是用户基数最大的一款JVM，随着每次的版本迭代升级，HotSpot对于内存区域划分管理的实现也在同步进化。

<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/02/2-7.png?raw=true" width="654"></div>

从内存划分中我们看到：

- JVM 堆中的数据是共享的，是占用内存最大的一块区域

- 执行引擎是用来执行字节码的

- 程序计数器用来恢复执行引擎在线程切换时的数据状态

- 本地内存包含元数据区和一些直接内存
  
JVM 的运行时区域是栈，而存储区域是堆。
堆外内存也会有部分受到 JVM 的控制，比如 native 关键词修饰的方法以及对内存的申请和处理。



### 3.关于“内存模型（JMM）”
JVM的内存模型规范意在屏蔽掉各种硬件平台和OS的内存访问差异，让程序在各个平台上通过相同的访问规则来访问各个变量。包括主内存，工作内存间的交互（通过JVM指令）规则，当线程间的变量值需要传递，都需要通过主内存。当多个线程在主内存中向同一变量读写数据，这时就涉及到了并发也就是线程安全问题。在并发场景下为了保证程序意图的正确执行，需要根据场景对三个特性进行关注，分别是：操作的原子性、可见性、有序性。为了既保证程序代码的正确性又有利用好部分硬件特性（寄存器，高速缓存等）来保障性能，**于是有JSR规范存在并且不断迭代来让Java内存模型成熟和进化**。比如有了比如指令重排、内存屏障这类具体规范来让Java并发程序既正确和执行速度，像volatile变量就是对上述三种特性中的可见性是一个典型的实现，而并不保证原子性，所以volatile更适合修饰一些天生就具有原子性的变量，比如很多场景下可以使用boolean类型的flag。
Java内存模型对一些指令集要求必须保证原子性，包括lock，unlock，read，load，assign，use，store，write（指令全集可以在JVM虚拟机规范中查看，指令集可以理解为一种中间语言让JVM执行引擎和OS交互，JVM为了保证更好的移植性，采取了基于栈而非寄存器的指令集），对于以上基础特性不同程度的实现可以灵活的满足我们不同的并发场景。
<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/02/2-9.png?raw=true" width="777"></div>
<div align=center>关于"内存模型"</div>


### 4.关于“运行期优化”
上面在类加载部分提到了基于Java代码编译成字节码的过程，我们可以对代码的基础语法做出一定程度的优化和创新，而在对指令解释执行的过程中，JVM本身也没有放过优化这件事，毕竟单纯解释执行的效率确实不如人意是可能会被诟病，并且影响语言本身的素质和发展的。
JVM在运行期的优化手段也层出不穷，从各种场景进行了很聪明的优化，**这些努力使得Java的运行期性能不输于离底层更近的C/C++等语言，甚至在一些场景下经过“智能”的优化后的表现甚至要好过一些底层语言，这也正是[局部性原理（另一篇博文）](https://github.com/BBLLMYD/blog/blob/master/blogs/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9C%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E2%80%9D.md)的一个应用**。在JVM这个“中间件”上付出了投入了足够多的心力和智慧，是Java语言如今发展的比较好的一个很重要的原因。
这些优化手段可以从很多方面来概括，实际上我们其实很少能真正的参与进去，更多的是作为一个受益者的角色，举几个具体的优化技术例子：方法内联、逃逸分析、公共子表达式消除等等。全部都优化技术加一起大概有数百种之多，根据二八定律，其实真正起更显著作用的可能主要集中在其中几种，当然，优化手段这件事本身也在进行持续的优化中，我们对未来的JVM还抱有着更大的期待。

虽然我们也许很少机会能干预到这些后端编译优化的过程，但是了解其机制对我们能够编写出更适合内联等优化机制友好的代码。

<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/02/2-11.png?raw=true" width="555"></div>
<div align=center>关于"运行期优化"</div>


### 5.关于“垃圾收集”
关于垃圾收集，是我们较需要投入精力关注的事情，因为如果相关的配置和我们代码的业务场景不是很适合，可能会对我们的应用造成较差的影响。
在JVM内存布局结构中，可以以线程私有和线程共享的角度来进行分类，其中程序计数器、虚拟机栈、本地方法栈都是跟着线程工作周期存活，可以自动的进行清理。而实际上我们的线程私有的空间一般情况下也不会存大的对象，存的通常是一些基础数据类型以及指向堆空间的引用。当指向一个堆内对象的各个引用被回收，意味着这个对象也就被不会再继续被使用，成为了需要被回收的“垃圾”对象。刚刚提到的引用其实可以是个抽象的概念，因为JVM为了更高效灵活的管理内存，将引用也细化出了强、弱、软、虚引用等不同程度的实现，具体的特性和应用又可以展开个大的篇幅去说。回到垃圾收集，确认一个对象是不是成为垃圾一般有两种方式应用较多，一个是引用计数，一个是可达性分析，像redis采用的是引用计数方向的实现，JVM采用的是可达性分析方式。
垃圾回收算法常见的实现有：标记-清除、复制算法、标记-整理等等，这些算法由不同的垃圾收集器分别具体实现。我们启动进程时可以结合业务场景特性来选择更适合的算法，显式的指定在不同的细分区域使用不同的收集器。
收集器的有很多种，比较常见的包括Serial、Parallel GC、CMS、G1等，垃圾收集器作为实现垃圾收集算法的重要模块，本身也在随着版本升级不断进化，也不断有着新的高性能的收集器出现。我们虽然完全没必要去完全记住每一个收集器的工作方式和特性，但是**对各个收集器对资源的掌控取舍和利用情况，是我们值得去关注的**，比如当我们的应用程序是一个关注吞吐率而上层没有过多交互场景的时候，我们就可以降低对用户线程影响的需求，而更高效的利用CPU时间，这时选择Parallel就是最适合的；如果我们的应用程序工作线程有频繁的交互场景，不能容忍STP过多的时候，CMS这种以缩短停顿时间为目标的收集器此时更适合。
对于不同区域不同的收集器组合多去理解和实验，在对比下一定可以找到最适合当下的配置实践。
随着JVM版本的迭代，包括内存划分的规则等可能都在进化，新的收集器也在不断出现，可能会出现旧版本启动参数对新版本已经不适用，所以当我们的使用环境升级了虚拟机平台版本的同时，如果有着显示的启动参数等制定策略，最好不要忽略了再次比对的重要意义。
没有显式指定的时候JVM有默认比较适普的策略，所以当脱离了具体场景时这种指定方案并不存在一个“最佳实践”，而一定是灵活的。
<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/02/2-13.png?raw=true" width="444"></div>
    
    在Java7/8中比较常见的组合策略通常在上图的范围内，可以支持比较灵活的调试和实验，
    随着JVM的发展，可能会有更强大的一站式的收集器出现，但是我们最好也不要陷于这些五花八门的表象，
    无论哪种收集器本质上都是对资源的管理，根据我们应用特性来寻找调优的侧重点是才是不变的方向。


### 6.关于“处理工具”
程序运行的时候JVM对于我们来说可以说是个黑盒子，一切平稳运行还好，当出现OOM，严重STP，内存泄漏等问题的时候，我们一定要知道当下的内存状况是什么样的，此时我们需要借助各种工具来找我们所需要的信息。这些信息需要结合包括但绝不限于上述的各种JVM相关知识才能有价值。JDK本身为我们提供了各个查看各个维度信息很好用的原生工具，可以获得你的应用下一手的JVM数据，市场上更有很多成熟的更人性化的监控工具产品来帮助我们寻找和排查问题，**但是大部分的功能也是基于JDK原生的工具作为基础来包装的**，所以我们还是要从基础的原生工具开始了解，这样无论遇到再花哨的监控工具，也都不会疑惑。
**从排查过程来讲，对JVM知识的了解是一个基础支撑，堆栈数据、GClog作为数据，JVM工具和操作系统知识就是助手，这个流程需要们对各个环节都有足够充分的了解和累积才可以做到。**
<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/02/2-12-1.png?raw=true" width="777"></div>

<br>


### 7.其他 & 总结

> **知道全部的真相才能获得全部的自由**

关于JVM要想知道“全部的真相”可能得撸源码了，难度有点大，JVM是个大工程，有太多的细枝末节。背后有很多的专家们在支撑和探索创新才有了这么客观的发展。
不过作为JVM语言的使用者，了解JVM设计的一些抽象的大方向，和一些与我们相关的具体实现方式，这样即使不能获得全部的自由也可以得到一些“相对自由”。
**JVM的实现千变万化（虽然大多数也都是用的那几个），但是JVM规范的变化总是有限的，在规范的基础上实现就总是有边界的。**
在我们写代码的时候心里大概有一个代码在程序运行时的一些时间、空间感，这样不仅不容易写出问题代码，即使出现了突发的问题也可以相对更从容的应对，对我们的工作会有很大的裨益。

