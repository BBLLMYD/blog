**同步式编程写流程，响应式编程在写行为。**

维基百科：

> 在计算中，响应式编程或反应式编程（Reactive programming）是一种面向数据流和变化传播的声明式编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。

在这篇文字中说一说我理解的反应式编程，可能有些粗浅。

- [1.反应式的编程模型](https://github.com/BBLLMYD/blog/blob/master/blogs/%E6%B5%85%E6%9E%90Reactive%E6%A8%A1%E5%9E%8B.md#1%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B)
- [2.背压策略](https://github.com/BBLLMYD/blog/blob/master/blogs/%E6%B5%85%E6%9E%90Reactive%E6%A8%A1%E5%9E%8B.md#2%E8%83%8C%E5%8E%8B%E7%AD%96%E7%95%A5)
- [3.其他 & 总结](https://github.com/BBLLMYD/blog/blob/master/blogs/%E6%B5%85%E6%9E%90Reactive%E6%A8%A1%E5%9E%8B.md#3%E5%85%B6%E4%BB%96--%E6%80%BB%E7%BB%93)

---

### 1.反应式的编程模型

Reactive（反应式）是一种编程风格，主要特点有异步或并发、观察者模式衍生的事件驱动、推送机制等。
反应式体现在"随时响应刺激"。

> 响应式编程是使用异步数据流进行编程

数据流Stream已经不是新鲜的东西，我理解在反应式编程模型中Stream可以视为一个基础设施，
也就是说反应式编程是Stream序列模型、观察者模式、事件机制的组合应用。

**随时准备接收事件**是反应式编程的本质。

事件在系统中可以有着不同的体现，如读/写事件（I/O）、失败事件（fail）、请求事件（request）等。

#### 事件驱动模型的一些"利" 与 "弊" 

其实不仅是在js和移动端领域，在后台应用中的事件驱动其实也是比较常见的，而且并不难理解。
比如Netty事件驱动的网络模型，Spring对Reactor的支持，
或者我们自己封装的一些观察者模式的接口等等。

Reactive模型追求的几个特性：

- 响应性：快速/一致的响应时间；
- 韧性：主要是系统对错误的容忍，某个模块出现问题时，将这个问题控制在一定范围内，避免发生连锁性问题；
- 弹性：没有状态就进行水平扩展，存在状态就需要使用具体的分片技术；
- 消息驱动：基础模式，也是实现上述特性的基本支撑

在相比于基于同步方法调用的模式，上述这些基于事件驱动的异步通信能够做到减少阻塞和松耦合的效果，
可以达到更低延迟和更高的吞吐量，**事件驱动下避免出现不断地轮询或等待数据可能导致的资源垄断，** 更高效率的利用资源。
发送方和接收方不关心事件是如何传播的细节，通过接口的方式易于扩展和维护，更加灵活。

Reactive内部的实现也是将OS的线程池化，并在整个应用程序生命周期中重复使用它们。
所以要清楚无论是到什么时候，程序处理的本质仍然是离不开对多核处理器的应用形式。
另外一个本质是I/O处理中的阻塞在阶段其实是不能完全避免的，**要做到的其实是可控，**
如何能够可控的同时又做到高效是在不同场景下的不同选型来做的。

> 响应式编程关注于数据流而不是控制流

从程序视角上，事件的产生和处理的解耦，在数据流中互相协作，可以让消除复杂的组件之间的依赖，
并且可以选择性的让业务组件屏蔽一些基础设施如线程和锁，更专注于事件如何传播以及如何通过系统组件之间进行交互。

"Fire and Forget"这种异步模式自然也不是都是优点，
在弥补了一些同步编程的好处的同时，**自然也会受制于一些异步编程模式带来的局限和问题。**

首先是受制于编程模型，反应式代码的思维方式与编写传统代码的思维方式非常不同，当然这些影响决于开发人员本身。
但是要承认如果并不熟悉反应式编程模型，无论是读还是写代码或是 debug 都是有些阻力的，需要一些基础知识和反应式编程模式的思想支持。
在反应式编程中一些相对复杂的状态维护也许可以被规避掉，但是比如 ThreadLocal 方式的变量传递就可能会产生问题。

---

### 2.背压策略

我认为其实在 Server 端服务中背压（BackPressure）这个机制或者策略，其实一点都不新鲜，甚至是很常见的。

在Reactive流里的下游消费速度小于上游生产速度，此时将有一个Buffer的角色来承载一定的缓冲数据，
而Buffer由于种种实际原因不可能有无限大，所以Buffer会满，而当Buffer满了后可以对新的生产数据对一些策略处理，比如让发送者稍后再试，或者使用其他接收器。

是不是觉得这套模式很熟悉，这和线程池的工作模式就是基本相似的。
另外只要是生产者-消费者模型，基本都是围绕着这套规则的。

在整个Reactive模式下看，BackPressure可以看作是用来控制订阅者速度过慢的问题的一个"中间件"角色。
**规则都抽象的，背压其实可以粗粒度的看成是应用到Reactive流下的一个新的名词而已。** 
与此同时结合着Reactive的特性和具体场景，针对 pull 和 push 模型来分别采取机制从而控制数据流的生产/消费速率的协作，
对于具有多个阶段的数据状态的处理会比较明显的效率上优势。


---

### 3.其他 & 总结

反应式编程的本质还是一种异步的**编程模型，** 无论是从编程思想上来说，还是从与云上设施协作以及资源合理利用的角度，
又或是与领域驱动（DDD）的方法论的结合，反应式编程都是一种很值得学习和实践的思想。





