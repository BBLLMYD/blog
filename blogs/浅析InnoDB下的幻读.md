
关于"幻读"现象的一些说法好像并不统一，下面摘一下来自百度百科引用。

> 幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用
    户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。


这里我也说一下我对幻读现象的理解，或者说MySQL的InnoDB引擎的幻读现象是如何处理的，
这篇主要就只讨论RR隔离级别下的幻读。基本不会对比着其他隔离级别以及脏读、不可重复读等现象。

- [1. 一些相关的技术背景](https://github.com/BBLLMYD/blog/blob/master/blogs/%E6%B5%85%E6%9E%90InnoDB%E4%B8%8B%E7%9A%84%E5%B9%BB%E8%AF%BB.md#1-%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8A%80%E6%9C%AF%E8%83%8C%E6%99%AF)
- [2. InnoDB引擎下的"幻读"](https://github.com/BBLLMYD/blog/blob/master/blogs/%E6%B5%85%E6%9E%90InnoDB%E4%B8%8B%E7%9A%84%E5%B9%BB%E8%AF%BB.md#2-innodb%E5%BC%95%E6%93%8E%E4%B8%8B%E7%9A%84%E5%B9%BB%E8%AF%BB)
- [3. 其他 & 总结]()

---

### 1. 一些相关的技术背景

- MVCC

MySQL多版本并发控制实现了MVCC机制，MVCC通过MVCC使用时间戳，或"自动增量的事务ID"等手段，意图解决读写锁造成的多个、长时间的读操作饿死写操作等问题。
其基础是快照读和当前读机制，所以每一行记录都有着一些隐藏列如DATA_TRX_ID、DATA_ROLL_PTR、DB_ROW_ID等。

- 相关的锁

**幻读现象出现的本质是因为没法锁住不存在的行。** 
大家知道在数据库标准的RR隔离级别下，是不可以避免幻读的，
而MySQL的InnoDB引擎通过next-key锁（行锁+Gap锁）来避免幻读（其实是在特定场景下能避免幻读）。
这也是导致说法不统一的一个重要原因。或者说，InnoDB是可以一定程度的避免幻读。

在一个事务内的读是要分为**快照读**和**当前读**的，
**如果在快照读操作（select）后面跟着当前读操作（select for update），那就是无法避免幻读的，是因为第二次当前读之前这时候next-key锁还没来得及发挥作用。**
也就是说这时候的"读"其实已经不仅仅是"读"了。

---

### 2. InnoDB引擎下的"幻读"

分别举个例子（**默认都在MySQL InnoDB的RR隔离级别下**）：

- 快照读造成的事务执行失败eg

|     T1     |     T2    |
|      :-        |     :-      |
|      `start transaction;`        |          |
|      1. `select * from users where id = 1;`        |           |
|             |     1. `insert into users(id, name) values (1, 'skrT2');`      |
|      2. `insert into users(id, name) values (1, 'skrT1');`     |           |
|      `commit;`     |           |

"skrT1"值会插入失败。但是这在T1事务内好像是自洽的，但是执行到T1.2步骤的时候会因为主键冲突无法插入，因为T2的事务操作结果此过程对T1是不可见的。

--- 

- "解决"上述流程的问题eg

|     T1     |     T2    |
|      :-        |     :-      |
|      `start transaction;`        |     `start transaction;`      |
|      1. `select * from users where id = 1;`        |           |
|             |     `insert into users(id, name) values (1, 'skrT2');`      |
|             |     `commit;`      |
|      2. `select * from users where id = 1 for update;`     |           |
|      3. `insert into users(id, name) values (1, 'skrT1');`     |           |
|      `commit;`     |           |

这次在T1 insert之前执行了一次for update的select，此时的读是当前读会读取到T2插入的数据，这时候虽然也会插入失败，好像T1事务内看起来至少合理了一些。
但是这种操作明显不太合自然逻辑了，而这种情况如果是在T1.1操做的时刻做for update的select是没意义的，因为上面提到了**锁此时没法锁住不存在的行**。

我理解这时候 for update类型的 select 更像是提供给用户用来拿到新版本数据的一个钩子，虽然这看起来和隔离的思想有些相悖了，但是这种设计必然有他的价值和适合应用场景。

所以此时只要不能阻塞T2的情况下，只要T2率先插入记录，T1是必然要回滚或者失败的。除非采用读写冲突的Serializable隔离级别下。

这里举的例子是简单情况下的insert操作，实际update操作也是同样的道理，锁只是手段，本质上都是**当前读和快照读的不一致，或者快照读读到的旧版本数据导致**。

- insert时的异常情况是，我本来要插入本应该能够合理（依据刚刚读出的逻辑）插入的数据，却出现了不能正常插入的现象（要插入的数据有可能被其他线程插入了）。<br>
- update时的异常现象是，我本来要更新本应该能够合理（依据刚刚读出的逻辑）更新的数据，却出现了没有正常更新的情况（要更新的数据有可能被其他线程给删了）。

到这里其实可以发现，实际上更多是取决于我们怎么定义"幻读"以及怎么利用或者避免，目的是在此场景下如何能保证程序的执行能够按正确的、我们想要的逻辑来执行。

---

数据库的四个隔离级别是一套规范标准，MySQL有MySQL的实现，Oracle有Oracle的实现；
到了MySQL的不同引擎还有着不同引擎的具体实现。
数据库的锁就是实现这些隔离级别的工具，根据锁的资源的粒度和读写场景有很多锁的实现，
与"幻读"现象更相关包括读锁，写锁，gap锁等。







