<br>

很多业务场景下也都需要用各种"锁"来控制并发场景对资源的各类操作。
各种同步手段可以说都是为了解决并发场景下对数据的操作而出现的，
而对数据的并发场景，多数都在多读多写、多读少写、少读多写、少读少写这几个常见范围内，
不同的并发场景下到达性能瓶颈节点的因素条件也不尽相同，
导致对于"锁"手段的方案选用和优化成了整体性能指标中很重要的一环。

维基百科中关于"线程/进程同步"的部分描述：

> 线程同步被定义为一种确保两个或多个并发进程或线程不会同时执行某些特定程序段（称为关键段）的机制。通过使用同步技术来控制进程对关键部分的访问。当一个线程开始执行关键部分（程序的序列化段）时，另一个线程应等待，直到第一个线程完成。如果未应用适当的同步技术，则可能导致争用情况，其中变量的值可能不可预测，并根据进程或线程的上下文切换的时间而变化。 

当要处理的资源操作控制在不同位置，往往也依赖着不同中间件的处理手段。
**由于不同中间件环境的上下文等条件不同，实现的方式上总会有所差别，但是控制逻辑的抽象往往都是相通或类似的。**

这一篇大概从下面几个方面出发，结合场景特点来展开讨论关于"锁"的各种实现和选型的方向。

- [1.程序进程内的锁]()
- [2.分布式锁]()
- [3.数据库锁]()
- [4.总结]()

- - -

<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/07/0701.png?raw=true" width="778"></div>
<br>

### 1.程序进程内的锁

由于Java中的线程单位是直接映射到操作系统线程的，所以Java中线程的状态切换也同步会带着操作系统线程切换本身的开销，
类似go语言中的协程机制，就可以相对更加细化锁的粒度，并且一定程度的避免开销。

#### 内置锁
#### 显式锁
#### 线程上下文切换的开销





### 2.分布式锁

分布式锁其实本质也是进程内的锁，只不过锁资源不再局限于上面的应用程序的进程内而是转移到了某个中间件的进程内，而通常中间件又是需要做高可用，
这又引入了分布式锁资源的一致性的问题。


### 3.数据库锁

### 4.总结


