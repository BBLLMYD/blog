<br>

很多业务场景下也都需要用各种"锁"来控制并发场景对资源的各类操作。
各种同步手段可以说都是为了解决并发场景下对数据的操作而出现的，
而对数据的并发场景，多数都在多读多写、多读少写、少读多写、少读少写这几个常见范围内，
不同的并发场景下到达性能瓶颈节点的因素条件也不尽相同，
导致对于"锁"手段的方案选用和优化成了整体性能指标中很重要的一环。

维基百科中关于"线程/进程同步"的部分描述：

> 线程同步被定义为一种确保两个或多个并发进程或线程不会同时执行某些特定程序段（称为关键段）的机制。通过使用同步技术来控制进程对关键部分的访问。当一个线程开始执行关键部分（程序的序列化段）时，另一个线程应等待，直到第一个线程完成。如果未应用适当的同步技术，则可能导致争用情况，其中变量的值可能不可预测，并根据进程或线程的上下文切换的时间而变化。 

当要处理的资源操作控制在不同位置，往往也依赖着不同中间件的处理手段。
**由于不同中间件环境的上下文等条件不同，实现的方式上总会有所差别，但是控制逻辑的抽象往往都是相通或类似的。**

这一篇大概从下面几个方面出发，结合场景特点来展开讨论关于"锁"的各种实现和选型的方向。

- [1.程序进程内的锁]()
- [2.分布式锁]()
- [3.数据库锁]()
- [4.其他相关]()
- [5.总结]()

- - -

<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/07/0701.png?raw=true" width="778"></div>
<br>

### 1.程序进程内的锁

由于Java中的线程单位是直接映射到操作系统线程的，所以Java中线程的状态切换也同步会带着操作系统线程切换本身的开销，
类似go语言中的协程机制，就可以相对更加细化锁的粒度，并且一定程度的避免开销。

#### 内置锁
内置锁synchronized从最初简单的完全互斥的实现方式，随着JDK的版本迭代内置的锁逻辑也在不断的优化，包括但不限于下面的几个方面：

锁消除：消除的判定基于逃逸分析的技术支持，明确了其实是线程私有的场景同步操作自然就可以取消。
锁粗化：当同步的模块很小又连续对其加锁且没有竞争的时候，虚拟机会把锁的粒度粗化到整体操作外部变成同一把，比如连续的append()操作。
偏向锁：这也是一个可配置参数的锁，可用-XX:+/-UseBiasedLocking来显示开启/禁止，
适应性锁：为了避免阻塞引入的自旋操作，避免自旋过多而浪费CPU引入了适应性自旋，次数阈值可以使用-XX:PreBlockSpin来显示指定。
以上的几个操作的实现和状态的更新，都是基于虚拟机对象头Mark Word的存储和标识位内容规范来实现的。

|     存储内容     |   标识位  |   状态   |
|      ---        |   ---    |    --    |
|  对象的hash码、分代年龄  |  01  |  未锁定  |
|  指向锁记录的指针  |  00  |  轻量级锁定  |
|  指向重量级锁的指针  |  10  |  膨胀（重量级锁）  |
|  空，不需要记录信息  |  11  |  GC标记  |
|  偏向线程ID、时间戳、分代年龄  |  01  |  可偏向  |

#### 显式锁

显示锁是由Java语言层封装的锁工具，提供了更灵活的特性配置，使用上虽然直观易于理解，
但如果使用不严谨也很容易发生锁泄漏的现象，并且在线程转储的时候有可能不包含锁的信息。
从我个人来讲，内置锁能够满足的情况下一般不会使用显示锁，大多同步场景确实内置锁也都是可以满足的，而比如一些需要公平锁实现的场景，使用显示锁会更方便。
并且在性能上，内置锁也在由虚拟机不断的进行优化中。我认为显示锁更大的价值在其设计思想上，
基于强大的AQS的基础队列，实现了一系列同步工具，ReentrantLock只是AQS的应用之一。


### 2.分布式锁

分布式锁其实本质也是进程内的锁，只不过锁资源不再局限于上面的应用程序的进程内而是转移到了某个中间件的进程内，而通常中间件又是需要做高可用，
这又引入了分布式锁资源的一致性的问题。


### 3.数据库锁

### 4.其他相关

#### 线程的活性故障
处于RUNNABLE状态的线程，也未必是一个正常工作的线程，如死锁、活锁、锁死、饥饿这几个状态，
，上面几个状态通常是由于编码的错误或者缺陷导致，在多线程环境中的开发要尽量避免这种可能性，出现可能会导致很严重的生产故障。
#### 上下文切换
#### 线程池死锁
#### 一些并发容器的实现思路
#### 线程上下文切换的开销


### 5.总结


