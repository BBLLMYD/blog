
协程是多任务编程下的一种机制，它的机制特性会适用于一些特定场景。
我们知道协程可以避免线程状态转换带来的上下文切换的开销，
但是也要意识到比如协程的执行如果有阻塞，那么将会阻塞整个线程。
而此时操作系统下的线程虽然相对重些，但相对更独立的隔离机制此时也是长处。

所以还是辩证的看待事情，谨记没有银弹。

维基百科：

> 协程（coroutine）是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程更适合于用来实现彼此熟悉的程序组件，如协作式多任务、异常处理、事件循环、迭代器、无限列表和管道。
 
“协程就是用户态的线程”可以这么理解：协程就是在用户程序中实现了协作式任务调度。

要理解是什么是“用户态的线程”，要先理解相对的什么是“内核态的线程”。 
内核态的线程是由操作系统来进行调度的，在切换线程上下文时，要先保存上一个线程的上下文，然后执行下一个线程，
当条件满足时，切换回上一个线程，并恢复上下文。 

协程也是如此，只不过，用户态的线程不是由操作系统来调度的，而是由用户程序来调度的，是在用户态的。
 
协程这种任务调度机制，让你的代码能够以串行顺序的写法去满足你需要的跳转的逻辑流，**并且不会导致操作系统级别的线程阻塞。**

比如Python 中的 yield 这个关键字就是用来产生中断, 并保存当前的上下文的, 
比如说程序的一段代码是访问远程服务器，那这个时候CPU就是空闲的，
就用 yield 让出CPU，接着执行下一段的代码，如果下一段代码还是访问除CPU以外的其它资源，
还可以调用yield让出CPU. 继续往下执行，这样就可以用同步的方式写异步的代码了.

这篇从下面几个方向讨论一些协程相关的内容：

- [1.协程 & 线程的比较](https://github.com/BBLLMYD/blog/blob/master/blogs/%E5%85%B3%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%BA%94%E7%94%A8.md#1-%E5%8D%8F%E7%A8%8B--%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83)
- [2.Java生态的"协程"](https://github.com/BBLLMYD/blog/blob/master/blogs/%E5%85%B3%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%BA%94%E7%94%A8.md#2-java%E7%94%9F%E6%80%81%E7%9A%84%E5%8D%8F%E7%A8%8B)
- [3.总结 & 其他](https://github.com/BBLLMYD/blog/blob/master/blogs/%E5%85%B3%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%BA%94%E7%94%A8.md#3-%E6%80%BB%E7%BB%93--%E5%85%B6%E4%BB%96)

- - -

### 1. 协程 & 线程的比较

协程可看作是控制流的一种形式。

协程是协作式多任务的，线程是抢占式多任务的。
协程的协作式相对抢占式调度所需要的时间代价要小很多，
但是由于不具备抢占式的特点，如果别人都不愿让出时间片就会出现永远得不到运行情况。

这其实意味着在不同的模式下我们的**多任务的编程模型也是需要随着改变的。**

这意味着协程提供并发性而非并行性。协程相对于线程的一个好处是可以用于**硬性实时**的语境，也就是说协程本身不受操作系统内核来直接管理。

在IO密集的场景下，相比线程协程可以把原本用于 iowait 的 cpu 时间片利用起来，在发生 io 时让 cpu 处理其他任务，来提高单核 cpu 的利用率。
要清楚一个本质的问题是 IO 操作本身即是系统调用，所以 IO 操作下是不可能完全避免阻塞和切换的开销的。

下面通过实现经典的生产者-消费者模型，来分别了解一下协程和线程的工作模式：

- 生产者－消费者：协程实现版：

```
Queue q := new queue

coroutine produce
    loop
        while q is not full
            create some new items
            add the items to q
        // 此处让出CPU
        yield to consume

coroutine consume
    loop
        while q is not empty
            remove some items from q
            use the items
        yield to produce
```

上面协程实现版本示例中的 yield 关键字可以让协程之间进行流程协作，逻辑简单程序也简单清晰，并且全程无需OS层参与。
        

- 生产者－消费者：线程实现版（Java）：

```
Queue queue = new Queue();

public void produce() {
    synchronized (this) {
        while (queue.isFull()) {
            wait();
        }
        queue.add();
        notifyAll();
    }
}

public void consume() {
    synchronized (this) {
        while (queue.isEmpty()) {
            wait();
        }
        queue.remove();
        notifyAll();
    }
}
// 省略了异常处理代码
```

线程实现版本示例中是比较容易想到的模式，这里采用了 Java 中的 wait 和 notifyAll 来实现两个线程间的通信。
过程中会有OS参与的工作，如线程阻塞、状态转换和上下文切换等。

也是由于OS的参的同时会带来一定程度的不可控性，不易做到硬性实时的特点。

从协程的实现版本可以发现几个特点：

- 协程的方式一定程度上可以减少对"状态"的维护
- 协程可以在函数内部且在用户态来做控制流程
- 协程不参与CPU时间分配也不直接受制于OS的调度


**协程主要是为了解决并发下的资源抢占等问题，而线程主要解决的是并行计算下的资源利用问题。**

所以虽然协程和线程是功能上相似，有一定的代替性，但并不是矛盾的存在，而是有各自更适合的用法。

---

### 2. Java生态的"协程"

Java的生态并不是一天两天构成的，就好像TCP作为传输层的基础协议已经覆盖了几乎所有可靠传输的基础设施，
这时候来的QUIC即使也有着可靠低延迟等等特性，但是围绕TCP的相关设施已经形成了**相当程度的惯性**。

并且这里有一个特点就是，TCP在逻辑上或许也是必然出现在前的，
因为QUIC的设计一定程度上是着力于TCP的一些缺陷和劣势。协程也一样，
一提到协程就知道比线程少了内耗的开销，因为线程的自然发展到一定程度，在某些方面的缺陷开始显现，自然就出现了新的解决方案。

还是要辩证的看问题以及从实际出发，协程还是线程的本质都是CPU资源，实际应用中Java的线程池已经基本解决了创建和销毁线程的开销，
业务中的线程现在基本都是由线程池来管理了。

很长一段时间内，计算机是只有一个核心，而这一个核却要运行多个程序，这中背景下，自然出现线程级别的上下文切换。
后来计算的的构成才慢慢发展成多核多线程，线程的切换也就自然随着时间缺省的延续下来。

而线程切换的实际开销上往往多是来自于各种I/O操作，I/O上导致的问题与其说是线程的缺陷，
不如也可以说是线程模型的选型导致的缺陷，
或者说高效合理的线程模型是基本可以规避掉这个问题的。

Java本身也有这方面的设计，以及庞大的Java生态（NIO/Netty/rxJava/Akka等）。
底层用NIO模式配合callback或者reactive模型编程，使用起来还是比较舒适的。

另外Java如果引入协程基本也会是增量的设计，像原生的 ThreadLocal 等机制的大面就应用，已经基本不会允许原生线程的机制上的改变了。

但是原生Java也在加强进行这方面的支持，如 [Project Loom](http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html) 就是一种相对原来的线程更轻量的一种实现机制，
在Java的基础包下可能会引入一个新的java.lang.Fiber，与Thread类在结构上是同级，设计的目标就是减少阻塞和切换等消耗，提高Java的并发能力，拭目以待吧。

---

### 3. 总结 & 其他

协程虽然是一种机制，但是它的概念和特性其实也是可以抽象出来的，这也正是为什么Java中虽然没有原生的协程支持，
因为在实际上的一些场景中协程能够解决的问题在Java生态中也有着很多解决问题的工具。

我认为协程的出现一定程度上是为了解决在计算机处理器从单核多多核的发展过程之中，
由于多线程的并行能力来处理并发时产生的一种"不是很适合"的现象，一定程度上也可以算是一种历史遗留问题吧。



