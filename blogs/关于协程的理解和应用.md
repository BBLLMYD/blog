
协程是多任务编程下的一种机制，它的机制特性会适用于一些特定场景。
我们知道协程可以避免线程状态转换带来的上下文切换的开销，
但是也要意识到比如协程的执行如果有阻塞，那么将会阻塞整个线程。
而此时操作系统下的线程虽然相对重些，但相对更独立的隔离机制此时也许会是长处。
所以还是要辩证的看待事情，谨记没有银弹。

维基百科：

> 协程（coroutine）是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程更适合于用来实现彼此熟悉的程序组件，如协作式多任务、异常处理、事件循环、迭代器、无限列表和管道。
 
“协程就是用户态的线程”可以这么理解：协程就是在用户程序中实现了协作式任务调度。

要理解是什么是“用户态的线程”，要先理解相对的什么是“内核态的线程”。 
内核态的线程是由操作系统来进行调度的，在切换线程上下文时，要先保存上一个线程的上下文，然后执行下一个线程，
当条件满足时，切换回上一个线程，并恢复上下文。 
协程也是如此，只不过，用户态的线程不是由操作系统来调度的，而是由用户程序来调度的，是在用户态的。
 
协程这种任务调度机制，让你的代码能够以串行顺序的写法去满足你需要的跳转的逻辑流，**并且不会导致操作系统级别的线程阻塞。**

比如Python 中的 yield 这个关键字就是用来产生中断, 并保存当前的上下文的, 
比如说程序的一段代码是访问远程服务器，那这个时候CPU就是空闲的，
就用 yield 让出CPU，接着执行下一段的代码，如果下一段代码还是访问除CPU以外的其它资源，
还可以调用yield让出CPU. 继续往下执行，这样就可以用同步的方式写异步的代码了.

这篇文字从下面几个方向来讨论一些协程相关的内容：

- [1. 协程 & 线程的比较]()
- [2. Java生态的"协程"]()
- [3. 总结 & 其他]()

- - -

### 1. 协程 & 线程的比较

协程可看作是控制流的一种形式。

协程是协作式多任务的，线程是抢占式多任务的。
协程的协作式相对抢占式调度所需要的时间代价要小很多，
但是由于不具备抢占式的特点，如果别人都不愿让出时间片就会出现永远得不到运行情况。
**这其实意味着在不同的模式下我们的多任务的编程模型也是需要改变的。**

这意味着协程提供并发性而非并行性。协程相对于线程的一个好处是可以用于**硬性实时**的语境，也就是说协程本身不受操作系统内核来直接管理。

在IO密集的场景下，相比线程协程可以把原本用于 iowait 的 cpu 时间片利用起来，在发生 io 时让 cpu 处理其他任务，来提高单核 cpu 的利用率。

下面通过实现一个经典的生产者-消费者模型，来了解一下协程和线程的工作模式。

- 生产者－消费者：协程实现版：
```
Queue q := new queue

coroutine produce
    loop
        while q is not full
            create some new items
            add the items to q
        yield to consume

coroutine consume
    loop
        while q is not empty
            remove some items from q
            use the items
        yield to produce
```

上面协程实现版本示例中的 yield 关键字可以让协程之间进行流程协作，逻辑简单程序也简单清晰，并且全程无需OS层参与。
        

- 生产者－消费者：线程实现版（Java）：

```
Queue queue = new Queue();

public void produce() {
    synchronized (this) {
        while (queue.isFull()) {
            wait();
        }
        queue.add();
        notifyAll();
    }
}

public void consume() {
    synchronized (this) {
        while (queue.isEmpty()) {
            wait();
        }
        queue.remove();
        notifyAll();
    }
}
// 省略了异常处理
```

线程实现版本示例中是比较容易想到的模式，这里采用了 Java 中的 wait 和 notifyAll 来实现两个线程间的通信。
过程中会有OS参与的工作，如线程阻塞、状态转换和上下文切换等。
也是由于OS的参的同时会带来一定程度的不可控性，不易做到硬性实时的特点。

从协程的实现版本可以发现几个特点

- 协程的方式一定程度上可以减少对"状态"的维护
- 协程可以在函数内部且在用户态来做控制流程
- 协程不参与CPU时间分配也不直接受制于OS的调度

有一个本质的问题是 IO 操作本身是系统调用，所以 IO 操作下是不可能完全避免阻塞和切换的开销，

**协程主要是为了解决并发下的资源抢占等问题，而线程主要解决的是并行计算下的资源利用问题。**
这个角度来看他们虽然是功能上相似但是也并不是矛盾的存在。

---

### 3. 总结 & 其他

协程虽然是一种机制，但是它的概念和特性其实也是可以抽象出来的，这也正是为什么Java中虽然没有原生的协程支持，
因为在实际上的一些场景中协程能够解决的问题在Java生态中也有着很多解决问题的工具。

<br>



