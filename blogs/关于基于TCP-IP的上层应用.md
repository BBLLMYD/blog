<br>

TCP/IP协议的用途不用多说，是绝大多数应用采用的基础协议，
因为TCP/IP的特性是可靠传输。但是协议的本质毕竟是规范，
真正完成协议所规范内容的还是需要硬件和操作系统支持。
并且网络环境有太多的不可控，丢包、乱序、重传、拥塞现象常见，
既然是承诺可靠的协议，针对以上现象就都需要作出相应的算法策略来保障可靠性。

> TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。TCP/IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。并且，TCP/IP传输协议是保证网络数据信息及时、完整传输的两个重要的协议。TCP/IP传输协议是严格来说是一个四层的体系结构，应用层、传输层、网络层和数据链路层都包含其中。

上面说到对于丢包、乱序等现象TCP本身有算法来保障数据正确传输，
但是当我们基于TCP做上层应用时，还是有一些问题是需要在应用层做保障的，
比如长连接下的粘包拆包现象，TCP保证了数据在传输层的可靠性，
但是这些字节数据在TCP层面是无状态的，由于TCP的缓冲区机制可能导致应用层收到了半包或者粘包的数据。

因为TCP是面向字节流的协议，"流"本身可以看作是无状态、保证传输的时序顺序的不间断无逻辑边界的字节数据。
和UDP对比来看，TCP有缓冲区，而UDP面向报文段是没有缓冲区的。
TCP发送报文时，是将应用层数据写入TCP缓冲区中，然后由TCP协议来控制发送这里面的数据，
而发送的状态是按字节流的方式发送的，**跟应用层写下来的报文长度没有任何关系**，所以说是流。
而UDP没有缓冲区，应用层写的报文数据会直接加包头交给网络层，由网络层负责分片，所以说是面向报文段的。

上面说到和应用层写下来的报文长度关系，也就是传输层此时一定程度上是不关注或者说不负责检查应用层写的数据内容和大小，
这些数据在传输层都是无差别的无状态的字节流。
那么在基于TCP传输的长链接场景，比如在应用程序写入的数据大于套接字缓冲区大小时，将会发生拆包现象；
应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上时将会发生粘包现象等。
总的来看可以说既有由于操作系统和硬件的工作机制导致、也可能有协议本身的机制限制导致发生，
因为这数据粘连的影响是在应用层才能体现的。也就需要在应用层面上来解决粘包拆包带来的问题。

- 从收发的角度：一个发送被多次接受（拆），多次发送被一次接受（粘）。
- 从传输的角度：一个发送占用多个传输包（拆），多个发送共用一个传输包（粘）。
                                            
<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/09/0901.png?raw=true" width="798"></div>

 
<br>



