<br>

首先明确当前应用在当下阶段优化的必要性是不是真的存在，此时应用是否看到了瓶颈，或者说调优是一定要有目标来驱动，杜绝盲目的优化。
如果当前应用是以计算为主的CPU密集的应用，自然就比较需要关注CPU吞吐率情况；
如果是IO密集的应用，自然就比较需要关注影响IO瓶颈和稳定性相关的指标；
如果追求低延时的响应应用，就需要尽量避免出现停顿用户线程的情况；
如果是内存紧张的环境，内存占用也可以是我们优化方向。
不同类型的应用都有优化的空间和方向，但是早期健康的应用程序的瓶颈还不清晰，无法准确找到优化方向， 
这时候做优化是不合理并且是很难做出真正有效的优化的。
虽然过早的优化是不建议的，但是随着时间累计，
有的应用总是会出现越来越多的数据要处理、越来越大的流量在出入、越来越稳定和快的系统响应需求等等。
此时伴随着系统不停迭代，性能层面的优化是自然也是必然要做的。
对业务模型有着深刻的理解，可以在系统的迭代和发展的方向的把控上更加合理，节省成本少走弯路。
对相关基础知识扎实的掌握，能够做出有效的，对当前应用特点有针对性的性能上的优化。

在已有的业务模型基础上，从宏观到微观的优化方向和思路，
大多数优化的本质还是**从当下场景出发 做最适合的选择**，
真正做到有针对的创新性的优化还是偏少数的，毕竟定制造轮子或是试错的成本都是极高的。

- [1. 从"架构模式"出发：]()
- [2. 从"OS & 网络"出发：]()
- [3. 从"应用"本身出发：]()
- [4. 从系统所处阶段看稳定性手段]()
- [5. 总结]()

---

### 2.从"OS & 网络"出发

绝大部分的后台应用都是部署在Linux系统上，想要最大化的合理利用系统资源，
对Linux下的CPU、内存、I/O、网络等方面的工作机制和原理需要有一定程度的了解，
因为我们的各种应用服务大多数的瓶颈总是离不开这些资源，
在关于[负载]()主题讨论的文章中有大致介绍过关于操作系统下资源的负载情况的模块，
这里我们来更有针对性的讨论一些关于应用在系统资源层面的导致的瓶颈的类别原因及相应优化。

#### 2.1 关于CPU

对CPU首先要避免在程序里出现死锁死循环等严重异常情况发生，
此时不只是应用程序运行的问题，严重的情况可能还会拖垮其他进程。
CPU正常使用瓶颈其实大多是来自于程序计算的算法复杂度、CPU的使用率异常以及对CPU不合理的频繁上下文切换。
当然也有在应用层针对CPU的特性做出高效利用的设计创新方式，
如[高效队列Disruptor]()就是通过应用层的设计最大程度的提升了CPU Cache的利用率，大大提高应用程序的吞吐能力。
（Disruptor中的一些设计思路和方式在另一片文章中有讨论）
根据任务的不同，CPU的上下文切换就可以分为几个不同的场景：进程上下文切换、线程上下文切换以及中断上下文切换。
我们主要谈一谈线程上下文切换，线程是调度的基本单位，而进程则是资源拥有的基本单位。
内核中的任务调度，实际上的调度对象是线程；而进程是给线程提供了虚拟内存、全局变量等资源。
所以同进程内的线程上下文切换切换，要比多进程间的切换消耗更少的资源，这也是合理资源管理的一个体现。
碰到上下文切换次数过多的问题时，可以借助vmstat、pidstat等工具来排查进而解决性能问题

<br>                                     
<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/10/1001.png?raw=true" alt="CPU性能相关" width="867"></div>
<div align=center>CPU性能相关</div>
<br>

上图中覆盖了一部分关于CPU性能的优化方向和方法，
但是也提到了其实有一个原则就是避免过早优化，一方面过早优化可能会增加不必要的复杂度，另一方面过早阶段无论是业务还是场景都处于相对高频变化的阶段，很难看清更远。
好的优化一定是是动态的、在相对都比较可控的情况下逐步完善的。

<br>

---

#### 2.2 关于内存

计算机中，只有内核才可以直接访问物理内存，Linux为用户进程分配独立同时连续的虚拟地址空间，进程访问的是虚拟内存，
这样各个进程的内存可以互相独立而且看起来是互不干扰的。
虚拟内存的部分又分为内核空间和用户空间，而且用户空间内存又根据存储数据的类别分为五个段（栈、文件映射、堆、数据段、只读段），
其中栈、文件映射和堆通常是用来给程序动态分配使用。
进程的虚拟内存需要通过页表，由系统映射为物理内存。虚拟内存加起来的地址空间一定比物理内存大很多，

上面提到的用户虚拟内存中的堆内存由应用程序自己来分配和管理，这些堆内存并不会被系统自动释放，除非程序退出。
需要在应用程序中明确调用库函数free()来释放它们。
**如果应用程序没有正确释放堆内存，就会造成内存泄漏，
泄漏的内存不仅应用程序自己不能访问，在OOM或者kill掉进程之前操作系统也不能把它们再次分配给其他应用来使用。**
所以在应用程序中一定要尽量避免内存泄漏的情况发生，如果一旦发生，要能够借助合适的工具如memleak、valgrind及时检测出原因。

Swap把一块磁盘空间或者一个本地文件，当成内存来使用。这样系统的可用内存好像就变大了，但是由于需要磁盘读写，换入换出时的访问速度可能会受到影响。
这是**时间换空间的思想的一种应用。但是实际上大多数的场景我们的程序更需要的都是时间，不仅不需要Swap机制，甚至还要避免带来的性能影响。**
如Java程序在gc的时候，要遍历所有用到的堆内存，如果有Swap的部分，遍历的时候肯能会出现磁盘I/O。
所以开启Swap其实会严重影响性能，大多数情况都需要关闭Swap机制避免性能的损失。
smem --sort swap命令可以看到各个进程的swap用量，如果有过高的情况可能就需要注意性能了。
需要Linux提供一些机制来应对内存不足的情况，如Buffer和Cache的回收、交换分区Swap以及OOM等机制，Linux系统中的缓冲命中率足够高的话也可以极大的提升I/O性能和吞吐率，但是这些都是由操作系统直接管理的。

在下面的图中总结了一些指标分类和相关工具，以及一些优化上的一些原则和思路。

<br>                                     
<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/10/1002.png?raw=true" alt="内存性能相关" width="867"></div>
<div align=center>内存性能相关</div>
<br>

--- 

#### 2.3 关于I/O

为了提高磁盘IO的效率，Linux利用了内存中缓存来适配协调磁盘和CPU的速度差值，


--- 

### 3.从"应用"本身出发



### 4.从系统所处阶段看稳定性手段

- 开发阶段-代码质量

1. 代码的扩展性、可读性、性能意识，持续集成
2. Code Review

- 运行阶段
    
1. 隔离、限流、熔断、降级
2. 监控、告警、链路追踪
3. 性能优化：监控系统中的曲线毛刺原因、GC、负载等方面

- 故障阶段

1. 故障预案恢复
2. 故障排查工具：包括但不限于上边提到的CPU、内存、磁盘、网络等方面的排查工具
    






### 5.从系统所处阶段看稳定性手段

上面提到的这些方面，实际应用中往往各个指标都是紧密相关的，当真的出现性能瓶颈，
一般从一个点顺藤摸瓜去找本质的原因，这需要在基础知识上有一定的深度和广度，才能尽可能快速准确定位到瓶颈，再快速准确的进行优化。
free、top、vmstat、pidstat、netstat是一些基础又强大的工具，而且输出的信息覆盖面比较大，可参考的维度也比较灵活。

