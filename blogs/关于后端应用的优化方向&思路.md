<br>

首先明确当前应用在当下阶段优化的必要性是不是真的存在，此时应用是否看到了瓶颈，或者说调优是一定要有目标来驱动，杜绝盲目的优化。
如果当前应用是以计算为主的CPU密集的应用，自然就比较需要关注CPU吞吐率情况；
如果是IO密集的应用，自然就比较需要关注影响IO瓶颈和稳定性相关的指标；
如果追求低延时的响应应用，就需要尽量避免出现停顿用户线程的情况；
如果是内存紧张的环境，内存占用也可以是我们优化方向。
不同类型的应用都有优化的空间和方向，但是早期健康的应用程序的瓶颈还不清晰，无法准确找到优化方向， 
这时候做优化是不合理并且是很难做出真正有效的优化的。
虽然过早的优化是不建议的，但是随着时间累计，
有的应用总是会出现越来越多的数据要处理、越来越大的流量在出入、越来越稳定和快的系统响应需求等等。
此时伴随着系统不停迭代，性能层面的优化是自然也是必然要做的。
对业务模型有着深刻的理解，可以在系统的迭代和发展的方向的把控上更加合理，节省成本少走弯路。
对相关基础知识扎实的掌握，能够做出有效的，对当前应用特点有针对性的性能上的优化。

在已有的业务模型基础上，从宏观到微观的优化方向和思路，
大多数优化的本质还是**从当下场景出发 做最适合的选择**，
真正做到有针对的创新性的优化还是偏少数的，毕竟定制造轮子或是试错的成本都是极高的。

- [1.从"架构模式"出发：]()
- [2.从"OS & 网络"出发：]()
- [3.从"应用"本身出发：]()
- [4.从系统所处阶段看稳定性手段]()

---

### 2.从"OS & 网络"出发

绝大部分的后台应用都是部署在Linux系统上，想要最大化的合理利用系统资源，
对Linux下的CPU、内存、I/O、网络等方面的工作机制和原理需要有一定程度的了解，
因为我们的各种应用服务大多数的瓶颈总是离不开这些资源，
在关于[负载]()主题讨论的文章中有大致介绍过关于操作系统下资源的负载情况的模块，
这里我们来更有针对性的讨论一些关于应用在系统资源层面的导致的瓶颈的类别原因及相应优化。

- 关于CPU

对CPU首先要避免在程序里出现死锁死循环等严重异常情况发生，
此时不只是应用程序运行的问题，严重的情况可能还会拖垮其他进程。
CPU正常使用瓶颈其实大多是来自于程序计算的算法复杂度、CPU的使用率异常以及对CPU不合理的频繁上下文切换。
当然也有在应用层针对CPU的特性做出高效利用的设计创新方式，
如[高效队列Disruptor]()就是通过应用层的设计最大程度的提升了CPU Cache的利用率，大大提高应用程序的吞吐能力。
（Disruptor中的一些设计思路和方式在另一片文章中有讨论）
根据任务的不同，CPU的上下文切换就可以分为几个不同的场景：进程上下文切换、线程上下文切换以及中断上下文切换。
我们主要谈一谈线程上下文切换，线程是调度的基本单位，而进程则是资源拥有的基本单位。
内核中的任务调度，实际上的调度对象是线程；而进程是给线程提供了虚拟内存、全局变量等资源。
所以同进程内的线程上下文切换切换，要比多进程间的切换消耗更少的资源，这也是合理资源管理的一个体现。
碰到上下文切换次数过多的问题时，可以借助vmstat、pidstat等工具来排查进而解决性能问题

<br>                                     
<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/10/1001.png?raw=true" width="867"></div>
<div align=center>CPU性能相关</div>
<br>

上图中覆盖了一部分关于CPU性能的优化方向和方法，
但是也提到了其实有一个原则就是避免过早优化，一方面过早优化可能会增加不必要的复杂度，另一方面过早阶段无论是业务还是场景都处于相对高频变化的阶段，很难看清更远。
好的优化一定是是动态的、在相对都比较可控的情况下逐步完善的。

<br>

---

- 关于内存



--- 

### 3.从"应用"本身出发



### 4.从系统所处阶段看稳定性手段

- 开发阶段-代码质量

1. 代码的扩展性、可读性、性能意识，持续集成
2. Code Review

- 运行阶段
    
1. 隔离、限流、熔断、降级
2. 监控、告警、链路追踪
3. 性能优化：监控系统中的曲线毛刺原因、GC、负载等方面

- 故障阶段

1. 故障预案恢复
2. 故障排查工具：包括但不限于上边提到的CPU、内存、磁盘、网络等方面的排查工具
    







