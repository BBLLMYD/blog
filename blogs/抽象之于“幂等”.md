<br>

"幂等"在网络词条中有下面的描述：
  
  
> 百度百科：<br>
  幂等是一个数学与计算机学概念，常见于抽象代数中。在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。<br>
  幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的。

> 维基百科：<br>
  在面向服务的体系结构（SOA）中，如果流程的任何部分失败，则可以重播完全由幂等步骤组成的多步骤编排流程，而不会产生副作用。

业务系统在分布式环境中，必然存在大量的网络调用，在写入数据系统节点的业务逻辑中，也一定会存在关于幂等的处理。
不管是来自上游的同步的网络调用，还是异步的消息消费，都存在是相同请求重复处理的可能性。此时幂等性设计的好坏既要保证数据的正确性也影响着整体程序的性能。

幂等性：满足f(x) = f(f(x))

处理幂等请求有很多实践方案，如幂等表方案、乐观锁（version版本号字段，状态机单向流转）方案、分布式锁方案等，
解决重复执行的副作用是幂等要解决的核心问题，下面分别从两个角度出发尝试更清晰的讨论对于不同场景下幂等的处理方法。

- [1.处理幂等请求步骤次序]()
- [2.从不同数据操作角度下看对幂等请求的处理方案]()

* * *

### 1.处理幂等请求步骤次序

不管是哪一种方案，处理幂等请求的大体步骤都是一样的。

- *1.1:识别相同的重复请求*

    当整体逻辑兼容了幂等请求时候（消息接受端此时不分区重复请求，对重复请求无特殊对待），这一步的识别动作可能并不是必要的，识别重复请求通常在insert数据时比较必要。
    
- *1.2:找到重复请求可能会产生的副作用并解决*

    如果是插入数据要确认是不是要避免重复提交；更新数据状态/量值要确认是不是已经更新过。
    
- *1.3:确定对于重复请求针对上层的响应模式*

    需要考虑是不是显示给上游响应本次的请求已经成功处理并且是重复请求，需要和业务协定。


* * *


### 2.从不同数据操作角度下看对幂等请求的处理方案

当业务逻辑对重复请求进行处理时候，场景不同往往对数据的操作形式也不同，这时要做到幂等处理也有各种不同的方案更适合。
通常来说select操作具有天然幂等的特性；
对于delete来说对于定位数据逻辑相关，绝对定位的方式通常不会出现问题，
一般的删除动作也是做逻辑删除，实际上也是update操作，通常主要需要关注范围都在insert和update中。

*2.1:数据查询&删除操作时*：

通常来说select操作具有天然幂等的特性，
对于关系库来说现在一般的删除动作也是做逻辑删除，
实际上也是update操作。

*2.2:数据更新操作时*：

对于update操作情况和可查考的解决方案也比较多就相对较多一些。<br>
下面是两种不同结果的示例，
第一种的绝对值定位到某条记录后再做固定的状态值的更新的情况，通常可以满足幂等，或者说不会造成脏数据落库。
第二种更新的值需要在历史数据上做计算，此时就需要对请求做良好的幂等处理。

```

/* 幂等操作（能保证数据正确性，但需要注意处理幂等请求的时候返回的影响行数不一致）*/
update table_x set del= #DO对象.del where id= #id;

// 非幂等
update table_x set num = num-1 where id= #id;

```
对于update操作有一些比较常见的幂等处理方案如下：

**- 新增version号字段 -**

可以很巧妙的通过CAS方式解决并发和幂等的问题
```
// version字段
update table_x set num = num-1 and version = version +1 
where id= #id and version = #DO对象.version;
```

**- 使用业务状态作为幂等处理字段 -**

逻辑是在处理前先判断状态是否符合预期，如果符合预期再执行业务。
状态字段需要单向不可逆，否则有可能导致ABA问题。由于触发动作的前置条件明确，这种机制还可以一定程度避免乱序问题。
```
// version字段
update table_x set status = NEXT_STATUS
where id= #id and status = #DO对象.version;
```
上述两个方案必要条件：需要上游服务带着version号或状态机字段作为入参信息

*2.3:数据插入操作*

**- 唯一约束 -**

可以根据业务上保证唯一性的字段或字段组合来做DB的唯一约束，处理幂等请求需要捕获特定异常。
唯一约束最好要有一个可以反映全局上下文的一个字段来参考，比如订单号，流水号之类的。
这里需要注意的是有的文章只说了雪花算法之类的唯一ID生成方式，没有明确生成唯一id的策略，
比如：谁来触发生成唯一ID的策略，幂等的请求如果携带着一致/不一致的唯一ID，此时需要处理的幂等的服务如何区别和处理。
**所以这个方案的本质问题还是要落到如何识别重复请求上**。同时，依赖数据库的唯一约束的时候也要注意数据库扩容场景下、甚至在Failover机制下**唯一索引的有效性问题**。


**- Token机制 -**

此方法通常是需要Client端在业务操作之前先进行一次调用取一次token，以token作参数再进行实际业务逻辑处理请求，需要多一次网络IO。
    
**- select + insert -**

insert前进行一次select，放在一个事务中时候可以满足幂等需求，不过此方法成本相对较高，并且读写分离下通常也有一定程度的延时导致不一致的问题。

*2.4:较通用的做法*

**- 独立建立一张独立去重表 -**

字段可以有id,幂等key，业务模块标识等字段。将幂等key和业务模块字段做唯一约束，
也属于通过唯一约束保证幂等，但是可以兼容insert和update等不同的操作，不关心业务对数据的处理方式。


***ps：*** 一、悲观锁和分布式锁虽然能够保证并发时的串行执行，**并发会引起幂等性，但是单有锁逻辑可以隔离线程却未必可以同时解决幂等问题**，
所以单单提粗粒度的锁方案这对于幂等问题的解决其实并不足够严谨。二、乐观锁/悲观锁的更新操作，最好**用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表**，就GG了。


<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/06/0601.png?raw=true" width="777"></div>
<br>

---

> 世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它。

上面这句话出自一位大神口中。有些问题，看起来很重要，但实际上我们可以通过合理的设计或者将问题分解来规避。
如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。
我觉得对于幂等的处理方案也是同样的道理，如果可以最好是不要采取可能会导致复杂性过高的重方法，可能也存在能够既分解了问题，也规避了风险的方法可以供我们选择，未必有了问题就一定要正面刚掉它。
       
考虑到幂等的处理，各种方案或多或少都会对业务有一点侵入型，对于后端处理幂等请求的成本和程序性能需要结合当下场景的特性来做选择。
实际应用前端通常会挡住或者避免大部分的幂等请求，
但是后端的服务并不能第一点抱着一个全盘信任上游的态度，更重要的第二点是分布式环境对于网络的不可靠是个长久的课题，
更何况往往无法保证上游是不是有超时重试的机制，又或是重复消息情况。
所以对数据正确性要求较高的写数据来说，有一个很贴合业务场景的幂等处理机制是很必要的。









