在计算机软件领域中有负载的概念，
在宏观上可以看做是一种解决高性能，单点故障（高可用），扩展性（水平伸缩）的解决方案，
将负载（包括工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。

常见专用的负载均衡组件如软件上的nginx代理服务器、偏硬件的F5负载均衡器等，就是为了让我们的服务在软件层面上达到一个"负载均衡"的状态。

维基百科：

> 负载平衡（Load balancing）是一种计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务通常是由专用软件和硬件来完成。 主要作用是将大量作业合理地分摊到多个操作单元上进行执行，用于解决互联网架构中的高并发和高可用的问题。

从微观上看，计算机操作系统中的对网络连接、CPU等资源的分配策略，
往往也影响着吞吐率和对资源的利用率是否合理，同时也是意味着应用服务或系统是否过载。

**负载是一个抽象的概念，在分布式业务系统或中间件中很多方面都有面对着"过载"状况的策略，
操作系统、网络以及容器编排器等也都有各自的负载均衡技术，用于使用各自的资源进行各自的任务调度。**

有时候由于业务上一些天然的[局部性特征](https://github.com/BBLLMYD/blog/blob/master/blogs/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9C%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E2%80%9D.md)，
比如秒杀中的热点商品等场景，也可能会由于数据特征可能会导致流量的不均衡，
进而相关组件的负载均衡的策略算法的采用如果不适合的话，可能会导致一些数据倾斜等问题，
影响系统的吞吐率和资源利用率，严重情况甚至会影响服务的可用性。

这篇我们主要从下面几个角度来分别讨论一下"负载"：

- [1.操作系统"负载"](https://github.com/BBLLMYD/blog/blob/master/blogs/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9C%E8%B4%9F%E8%BD%BD%E2%80%9D.md#1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD)
- [2.网络负载均衡](https://github.com/BBLLMYD/blog/blob/master/blogs/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9C%E8%B4%9F%E8%BD%BD%E2%80%9D.md#2%E7%BD%91%E7%BB%9C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1)
- [3.流量骤增下的"负载"](https://github.com/BBLLMYD/blog/blob/master/blogs/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9C%E8%B4%9F%E8%BD%BD%E2%80%9D.md#3%E6%B5%81%E9%87%8F%E9%AA%A4%E5%A2%9E%E4%B8%8B%E7%9A%84%E8%B4%9F%E8%BD%BD)
- [4.负载均衡算法](https://github.com/BBLLMYD/blog/blob/master/blogs/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9C%E8%B4%9F%E8%BD%BD%E2%80%9D.md#4%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95)
- [5.总结](https://github.com/BBLLMYD/blog/blob/master/blogs/%E6%8A%BD%E8%B1%A1%E4%B9%8B%E4%BA%8E%E2%80%9C%E8%B4%9F%E8%BD%BD%E2%80%9D.md#5%E6%80%BB%E7%BB%93)

* * * 

### 1.操作系统负载

操作系统的"过载"通常是由其上游的用户进程对有限资源的使用过度导致的，
当"过载"发生时，往往会导致应用程序卡顿变慢甚至停止运行。

一般根据用户程序工作偏重的类型不同，吃的主要资源也不同。
**CPU密集型应用往往都是大量计算类的程序，如高清视频解码、数学建模、加解密等，
瓶颈基本都是出现在CPU的吞吐率。**

Linux服务器下的CPU负载率可以通过uptime/top来查看，
但是load average（平均负载）的负载值所能表示的含义需要结合CPU的核数来看（cat /proc/cpuinfo），
单核的负载load average经验值认为低于0.7时是安全合理的；<br>
load average接近1表明CPU在全力运转；<br>
当load average大于4时CPU运行效率已经很低，**此时大量的CPU会大量浪费在进程切换这种系统的内耗上**，需要及时处理；<br>
现在基本都是多核的服务器，几核就按照上述单核状况下的数值乘以对应的核数作为参考。

实际上现在的load average 并非单纯指代cpu load average，
而是system load average。其实也包含一些I/O或者lock的wait情况的统计，
**是可运行状态（ps时处于R状态，正在使用或等待CPU的进程）
和不可中断状态（正处于内核态关键流程如等待IO的响应，
此是处于一种保护机制的模式下，ps时进程处于D状态）的进程的平均数量，也就是平均活跃进程数。**
而在CPU密集的计算型应用中这些额外数据的占比是基本可以忽略的。

而在IO密集型的应用中，通过load average数据就不足以判断负载情况了，
IO密集型的应用场景也特性较多，
各种长短链接、连接池、高并发低并发、大块数据传输等场景，
也是大多数后台（eg:Web应用）程序属于的类型。**此时要关注的资源不再单局限于CPU的吞吐，
CPU Loading并不高是因为CPU可能在很多时间在等I/O (硬盘/内存) 的读/写操作**。

更多的如网络IO、磁盘IO、应用程序的线程资源、操作系统的文件句柄等资源的紧张会导致系统出现瓶颈。
关于以TCP协议为通信基础的服务程序相关可以看一下[另一篇讨论](https://github.com/BBLLMYD/blog/blob/master/blogs/%E5%85%B3%E4%BA%8E%E5%9F%BA%E4%BA%8ETCP-IP%E7%9A%84%E4%B8%8A%E5%B1%82%E5%BA%94%E7%94%A8.md)。
对于涉及大量数据存取的中间件如mysql、mq、hbase等，
磁盘IO常会成为系统瓶颈。

````
// iostat工具可以查看系统IO相关指标
iostat
````

需要重点关注的指标字段：tps(磁盘每秒请求多少次IO操作)、avgqu-sz（IO队列的平均长度）、await（平均每一个IO花费了多少毫秒）、%util（磁盘的负荷程度，和磁盘个数正比 类似cpu load average参考方式）
相关的检测命令工具还有如vmstat、sar -b、iotop等。

影响磁盘IO的因素其实比较多，结合操作系统系统层面上如硬盘硬件的类型（ssd和hdd）和操作系统中的IO调度算法再结合应用程序读写特征，去配置适合的组合、以及文件系统缓存的优化等方向。
比如mysql系统，如果是SSD磁盘，那么应该指定NOOP调度算法，如果是磁盘，就更适用Deadline调度算法
CFQ：一般系统下默认的IO调度算法，但却不是适合的，数据库进程基本是IO最多的一个进程组，但却只能获得和其它进程一样多的IO调度机会。

Deadline: 按照截止期限来循环在各个IO队列中进行调度，所以它提供了一个近实时的IO系统，并且磁盘throughput也比较和，通常在hdd下比较适合。
NOOP：该调度算法特别适合于SSD。因为SSD在对待顺序IO和随机IO没有什么区别。所以它不需要对临近的IO进行合并。避免了合并操作对CPU的使用。

````
// 查看系统IO的调度方法，可在文件/boot/grub/menu.lst下指定修改
cat /sys/block/sda/queue/scheduler
````

在网络带宽和硬件配置的基础设施都已经能满足的前提下，
操作系统层面的配置也需要最大化的发挥硬件的性能，
提升吞吐率减少业务系统响应时间。

需要注意的一些系统参数配置如：
文件描述符数限制（影响服务同时能够处理的上游发来的连接数）、单个进程的最大线程数限制（与系统默认配置和线程栈默认大小相关）、
tcp内核参数等。


### 2.网络负载均衡

要知道服务的网络链路中，每多加一层，其实也是多了一层风险。

因为可能需要再一次的TCP要考虑的各种可能性也会随着多出一份，系统整体的不可控性又增加了一部分。
但是通常业务系统业务逻辑之外的"负载均衡"是一个不可缺少的必备条件。

所以在网络层上负责负载均衡的中间件也是必不可少的，因为无需关心业务逻辑甚至通信协议的细节，
所以他们通常需要具备的是高效的吞吐率和IO性能，封装了各种负载均衡算法可供选择。

负载均衡层做的事情主要有服务发现、健康检查、负载均衡。
但是带来的好处通常不止于此，比如对后端服务命名的抽象，统一类型的错误隔离、保护下游服务等。

既然是网络的负载均衡自然可以结合对网络协议内容来做负载策略，从OSI的通信模型来看，

- 通过虚拟MAC地址接收请求，然后再分配到真实的MAC地址称之为二层负载（数据链路层）；
- 通过虚拟IP地址接收请求，然后再分配到真实的IP地址称之为三层负载（网络层）；
- 通过虚拟IP地址+端口接收请求，然后再分配到真实的地址称之为四层负载（传输层）；
- 通过虚拟的url或主机名接收请求，然后再分配到真实的服务器称之为七层负载（整体应用层）。

通常接触的负载均衡设备或软件都属于四层/七层。

**由于应用层协议比较丰富，七层的负载相对可以更灵活易扩展，
可以根据应用层内容做不同的策略，对整体的服务在网络层面可以做到更"智能"。
可能产生新的流量，所以也可以看作是可以做"内容交换"的代理。

而四层的负载则更强调分发能力，不产生额外的流量，对物理资源消耗也较低，基于传输层也更普适。**
总的来说还是要看业务系统对负载的需求，如果在负载期间需要在应用层做文章，
就免不了要引入七层负载的组件如nginx，
如果只需在传输层负载转发工作四层负载更适合如LVS。

四层和七层负载并不是一个互斥的关系而是在整体架构里可以结合起来使用，发挥各自的优势和价值，
如LVS -> Nginx —> AppServer。


### 3.流量骤增下的"负载"

流量骤增下的负载涉及到的范围更广泛些，
不同业务场景下的性能瓶颈也不同，
如果流量多来自读取接口，就需要对静态资源动态资源合理利用缓存，尽可能的避免db等数据源成为瓶颈；
如果是用户量激增，针对这种可能无法预估体量的情况下 各种服务模块、存储系统、中间件都有可能成为系统瓶颈，
通常这时候需要及时有效的告警以及各种边界条件下的防御手段如自发扩容、限流、熔断策略的生效来确保服务最基本的可用性。

其实此时由于服务器总体能提供的正常的服务通常就是一个有限的体量，
此时当资源已经吃满，主要需要保证的是当过多流量打进来的情况下，如何能够不影响现有用户/线程的体验，
**也就是对已经不能提供服务的流量如何使用最少的资源成本处理，尽量避免和正常流量内的用户/线程去共享/抢占资源才是保证可用性的关键。**

无论是限流还是熔断也就是让多余流量尽量不再去往下游的服务沉，
此时更重要的对系统能够提供的服务体量范围的尽量准确的预估，
而这可能需要各种场景方位和维度的覆盖测试，做好了这个基本前提，下游各种保护策略才更加有其意义。

但是实际情况下业务的迭代可能也比较快，系统的实现也可能日趋复杂，此时处于变化状态的因素多而且往往都不是特别可控，这也是为什么流量骤增下服务经常会不可用的一个原因。

### 4.负载均衡算法

负载均衡的常见的实现算法大概有十几种，**脱离了当下的业务场景是没有绝对优秀的算法的，最适合的就是最优秀的选择**。这里根据算法的特点尝试总结分类。

<br>
<div align=center><img src="https://github.com/BBLLMYD/blog/blob/master/images/08/0801.png?raw=true" width="777"></div>

### 5.总结

"负载"从微观的角度看可以是IO、CPU吞吐率等操作系统甚至硬件组件层面上的负载，
从宏观来看可以是DNS负载、网络分层负载、业务系统负载。

无论是从哪个角度出发，目的都是要最合理高效率的利用现有资源。

<br>



